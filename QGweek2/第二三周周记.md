# QG训练营前端组第二、三周记：

* 由于一些奇妙的原因，我的二三周周记合在了一起，当然，这些都是无需在意的小事。

  
  
  ​																																QG前端组万天乐 2020年4月10日

##  生活随记

​		自己在家，自己生活，累了就躺，饿了就做饭，挺自在，也挺繁忙，因为不管多琐碎的事情都要自己去解决：牙膏没了、浴室门坏了、菜煮得不好吃...而且在我家这个偏僻的位置，没有外卖，自己动手丰衣足食。

​		不过就算是这样，每天也很充实，学习累了就看会电影，听会喜欢的音乐，开得再大声也没人会指责你，当然还是不要在晚上影响楼上下邻居的睡眠啦。

​		学习有点跟不上，尽管知道最后考试前突击肯定可以过关，但是这种心虚的感觉让人很不舒服，边学数据结构算法，学很多新的东西，开始都是很困难的，但是事情只要迈出了第一步，总是会慢慢变好的，我的目标不在于一定要进工作室，只是很想，为自己的大学生活赋予一些特别的意义，真的去为一些人事物而努力。

## 一周总结

​		这两周真是头疼的两周，甚至让我一度怀疑我是不是真的不适合计算机这门专业，我的C语言期末考分数是85，但是我在应用上的表现，让我感觉我是不及格的水平。

​		小到scanf的字符串输出该不该加&符号我都不能确定，大到怎么引用头文件，这些大大小小的问题都在我完成大组作业的时候困扰着我，对于别人来说轻而易举的作业，在我这里可能是百般阻挠的藤蔓。

​		我这两周独立补完了，第一周的单双链表、第二周的顺序栈和链栈（计算器实在是太多BUG，暂时未能完成）、第三周的泛型队列，庆幸的是我没有放弃，在完成第一周作业之后，后面的很多问题都被间接解决了。

​		然后小组作业，尽快搞定吧...很快的！！！

## 存在问题

### 一、二级指针传递参数

1. **概念**

**首先**

C是"一段内容",比如你用malloc或者new分配了一块内存，然后塞进去"一段内容",那就是C了。C的起始地址是0x00000008。

B是一个指针变量,其中存放着C的地址，但是B也要占空间的啊，所以B也有地址，B的起始地址是0x00000004,但是B内存中存放的是C的地址，所以B里面的内容就是0x00000008。

那么到此为止都比较好理解:

```c
B= 0x00000008;  //B的内容 
*B = "一段内容";  //B解引用，也就是B指针指向的C的值
&B = 0x00000004;  //B取地址，B的地址是0x00000004
```

那么，再来看A：
A是二级指针变量，其中存放着B的地址0x00000004,A也有地址，是0x00000000;

```c
*A = B= 0x00000008;  //A解引用也就是B的内容 
**A = *B = "一段内容";  //B解引用，也就是B指针指向的C的值
A = &B = 0x00000004;  //A存的是B的地址，B的地址是0x00000004
&A = 0x00000000;  //A取地址
```

2. **使用**

二级指针作为函数参数的作用:在函数外部定义一个指针p，在函数内给指针赋值，函数结束后对指针p生效，那么我们就需要二级指针。



### 二、限制用户输入

* **限制类型-泛型队列**

```c
void CheckType(LQueue* Q) {
	printf("\t\t\t|--------------------------------|\n");
	printf("\t\t\t|           数据类型选择         |\n");
	printf("\t\t\t|--------------------------------|\n");
	printf("\t\t\t|          1---整型              |\n");
	printf("\t\t\t|          2---字符型            |\n");
	printf("\t\t\t|          3---浮点型            |\n");
	printf("\t\t\t|          4---字符串            |\n");
	printf("\t\t\t|--------------------------------|\n");
	int t=1, s;
	printf("\n你想入队哪种类型？:\n");
	checkinput(&t);
	if (t > 0 && t < 5) {
		switch (t)
		{
		case 1: {
			int *a=(int*)malloc(sizeof(int));
			s = 4;
			printf("\n想入队的【整型数据】：\n");
			checkinput(a);
			EnLQueue(Q, a,s);
			break;
		}
		case 2: {
			char *a=(char*)malloc(sizeof(char));
			s = 1;
			printf("\n想入队的【字符型数据】：\n");
			scanf_s("%c", a);
			getchar();
			EnLQueue(Q, a,s);
			break;
		}
		case 3: {
			double *a= (double*)malloc(sizeof(double));
			s = 8;
			printf("\n想入队的【浮点型数据】：\n");
			scanf_s("%lf", a);
			getchar();
			EnLQueue(Q, a,s);
			break;
		}
		case 4: {
			char* a = (char*)malloc(20 * sizeof(char));
			s = 20;
			printf("\n想入队的【字符串型数据】（最大长度为20哦！）：\n");
			gets(a);
			EnLQueue(Q, a, s);
			break;
		}
		}
	}
	else
	{
		printf("\n应输入在[1,4]之间的整数！\n");
		CheckType(Q);
	}
	return;

}
```

* **限制字符输入**

```
void checkinput(int* r) {
	int error, i = 0;
	char c[50] = { 0 };
	do {
		gets(c);
		error = 0;
		for (i = 0; c[i] != '\0'; i++) {
			if (i == 0 && c[i] == '-')
			{
				continue;
			}
			if (c[i] < '0' || c[i]>'9')
				error = 1;
		}
		if (error) {
			printf("输入错误，请重新输入！\n");
		}
	} while (error);
	*r = atoi(c);
}
```



### 三、void*的用法

* **C语言中的void 和 void * 总结**

1. **void的作用**

　　c语言中，void为“不确定类型”，不可以用void来声明变量。如：void a = 10；如果出现这样语句编译器会报错：variable or field ‘a’ declared void。

　　在C语言中void 常常用于：**对函数返回类型的限**定**和对函数参数限定**　　

　　（1）对函数返回类型的限定：当函数不需要返回类型是必须用void 来限定返回类型，限定了函数的返回类型为void后函数不能有返回值；如：void fun（int a）；

　　（2）对函数参数类型的限定：当函数不允许接受参数时必须用void 来限定函数参数，限定了函数的参数类型为void后函数不能有参数；如：int fun（void）；

2. **`void *` 的作用**

   在C语言中`void *`是一个很有意思的玩意。

　　C语言中`void *` 为 “不确定类型指针”，`void *`可以用来声明指针。如：`void * a`；

　　（1）void *可以接受任何类型的赋值：

```c
		void *a = NULL；

		int * b = NULL；

		a = b；/*a是 void * 型指针，任何类型的指针都可以直接赋值给它，无需进行强制类型转换

		我们可以认为void就是一张白纸可以在上班写任何类型的数值。*/
```

　　（2）void *可以赋值给任何类型的变量 但是需要进行强制转换：

　　　　例：

```c
		int * a = NULL ；

        void * b ；

        a = （int *）b；
```

　　但是有意思的是：`void*` 在转换为其他数据类型时，赋值给`void*` 的类型 和目标类型必须保持一致。简单点来说：`void*` 类型接受了`int *` 的赋值后 这个`void *` 不能转化为其他类型，必须转换为`int *`类型；

　　例如：

```c
 1 #include <stdio.h>
 2 
 3 int main (){
 4      int a= 10;
 5      void *b = &a;
 6      
 7     printf("int a = %d\n",a);
 8     printf("void (int *)b =%d \n",*(int *)b);
 9     printf("void (double *)b =%d \n",*(double*)b);  //编译器并不会报错但是其结果却有点出人意料
10     return 0;
11 }
```

其结果也是各种各样：

```c
 1 //---------结果1------------
 2 int a = 10
 3 void (int *)b = 10 
 4 void (double *)b = 0.000000
 5 //---------结果2------------
 6 int a = 10
 7 void (int *)b = 10 
 8 void (double *)b = -169647784854594875714536834205830109813973725378637218342762753874027478154937823064700382247683481669586551809051934352771907584.000000 
 9 //---------结果3------------
10 int a = 10
11 void (int *)b = 10 
12 void (double *)b = 34358259312695588917830681637977768958357475343550314389004097648860261285241908341765401934913254730158595756720077705865303504367068899764349319628379837559354067484428780872228917036881492490184001083932672.000000
```



### 四、数组名退化成指针的三种情况

从一道小题下手（该考点曾被腾讯等大公司作为基础笔试题考过）

```c
#include <stdio.h>
 
int size(char a[10])
{
    return sizeof(a);
}
 
int main(void)
{
    char a[] = {'C','h','i','n','a','\0'};
    char *p = "China";
    char *q = a;
 
    printf("sizeof(a)=%d\n", sizeof(a));
    printf("sizeof(p)=%d\n", sizeof(p));
    printf("sizeof(q)=%d\n", sizeof(q));
    printf("size(a)=%d\n", size(a));
 
    return 0;
}
```

在32位机的编译环境下，结果为：

```cpp
sizeof(a)=6
sizeof(p)=4
sizeof(q)=4
size(a)=4
1234
```

基于本小题，主要考究以下几点：

#### 数组名退化成指针

##### 仅在以下3种情况中，数组不会退化成指针，

1. 使用sizeof(a)的时候，所以上面sizeof(a)的结果为6字节
2. 对数组名取地址操作：&a。&a的类型为pointer to array of 6 chars，而对字符串指针取地址结果为pointer to pointer to char.
3. 使用字符串初始化数组的时候也不会退化。

其它情况都会退化成“指向数组首元素的指针”，比如：

1. 数组名做函数参数时，a都会退化成&a[0]指针。如上面的size函数和printf函数中的a[]都是这种情况
2. 二维数组，char s[10][8]数组的首元素（得理解这个首元素，从一维数组的角度看的）是一维数组s[0]，因此退化成&s[0]指针

##### 数组定义字符串和指针定义字符串的区别

1. 使用数字定义的字符串只分配字符串所需的空间（上例中为6个字节），数字名没有单独的存储空间；使用指针定义字符串，除了字符串占用的空间，还要为指针变量分配对应的空间。
2. 数组退化成指针为“常量指针”，不可更改，而直接指向字符串的指针可修改，如

```c
char a[10] = "China";
char *p = "China";
a++;   // 错误的
p++;   // 正确的
```



### 五、scanf语句被跳过的解决方案和缓冲区

> **作为初学者（对！就是我！一直排这个错！快被整毁了！），可能会经常莫名遇到“为啥我的第二个scanf（）函数自动跳过，不等待我输入就自己执行了？”的问题，或者会遇到“为啥在我输入数据和回车之后程序没有反应？”，以下是浅薄的解释：**

#### 问题一：“为啥我的第二个scanf( )函数自动跳过，不等待我输入就自己执行了？”

一个很简单的例子：

```c
#include <stdio.h>
/*试图两次利用scanf()函数，先后读取整型变量a和字符型变量c*/
int main()
{
	int a;
	char c;
	scanf("%d",&a);
	scanf("%c",&c);
	printf("%d %c",a,c); 
}
```

> **解析：当我们输入：123 ↙**
> **会发现程序会“直接”打印整数123，好像并没有给我们留下时间和空间输入字符型变量c的值（一开始我也一脸懵B？？）.**
> **但是，经过调试（啊，万能的调试！），我们可以发现，其实整型变量c已经读入了值‘\n’，即ASCII码为10的字符——换行符;**

**实际上：**
函数scanf( )从标准输入设备(键盘) 读取输入的信息，不会直接赋值给变量，而是**先储存到一个缓冲区**中；

当程序执行到函数scanf()时，程序会从缓冲区中读取；

如果缓冲区是空的，才会停滞，光标闪烁，等待键盘的输入.

**值得注意的是**，scanf()中格式字符串里：

* 对于参数%d：会忽略缓冲区开头的空白符（空格、回车、制表符等）（无论有几个）；
* 对于参数 %c：直接读取缓冲区的第一个字符（无论这个字符是什么）；

故，上例中：

1. 向缓冲区中输入：123\n
2.  语句scanf("%d",&a); 读取走了123，赋给变量a；
   （缓冲区变化：123\n → \n）
3.  语句scanf("%c",&c);读取走了**\n，赋给变量c**；
   （缓冲区变化：\n → 空白）

解决方法：

1. 利用函数getchar( )吃掉回车：在scanf后接一个getchar( );

```c
#include <stdio.h>
int main()
{
    int a;
    char c;
    scanf("%d",&a);
    getchar();/*吃掉回车*/
    scanf("%c",&c);
    printf("%d %c",a,c); 
}
```

2º 利用函数fflush( )清除缓冲区：如fflush(stdin);

```c
#include <stdio.h>
int main()
{
    int a;
    char c;
    scanf("%d",&a);
    fflush(stdin);/*清除输入缓冲区*/
    scanf("%c",&c);
    printf("%d %c",a,c); 
}
```

**注意 注意 注意 ：**

有同学可能用的是**新版的vs**，不支持该方法2；可以试一下替换成rewind(stdin)函数;

或者可以直接一次性读取两个数据scanf("%d%*c", &c);——**注意星号*****！**

这句话的意思是就是说：读取一个整数后，丢弃紧跟在整数后边的一个字符（也就是我们多输入的“回车符”）；

有问题的试一下吧…

#### 问题二：“为啥在我输入数据和回车之后程序没有反应？”

——在函数scanf( )的格式字符串中加入\n的问题：
例如：

```c
#include <stdio.h>
int main()
{
	int a;
	scanf("%d\n",&a);/*注意%d后的\n*/
	printf("%d",a);
}
```

这种情况下，按照**“整型数字 回车”的格式读取**，读到回车之后，由于**缓冲区空白**，程序停滞，程序停滞，光标闪烁，等待键盘输入；故，当你输入一个整数和回车后，a的值不会立即打印，要等再接收到一个非空白符（即非空格、回车、制表符等）的输入之后，该scanf语句才结束，接着才输出。

总之，在使用函数scanf( )时，应该心中有一个缓冲区，合理利用相关函数来解决键盘缓冲区残余信息的问题；同时，理解读取格式，以便搞清楚何时函数scanf( )结束；啊啊啊加油加油！



## 下周规划

* 如果说大组的数据结构还会继续学下去的话，那就应该是字符串、数据、广义表、树、图，总之继续自学数据结构。自学的方式如下：

  [C语言中文网]: http://c.biancheng.net/
  [【C语言描述】《数据结构和算法》（小甲鱼）]: https://www.bilibili.com/video/BV1jW411K7yg/?p=13
  [数据结构-浙江大学]: https://www.bilibili.com/video/BV1JW411i731/

  

* 前端学习，主要还是继续学习js，然后是前后端交互，了解接触后端技术

  [w3school]: https://www.w3school.com.cn/

  